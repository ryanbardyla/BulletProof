//! NeuronLang Code Generator - Compiles AST to executable code
//! 
//! Generates Rust code that can be compiled to native binaries.
//! Targets trinary neural networks with zero-energy baseline.

use crate::parser::{AstNode, Declaration, DeclKind, BrainDecl, PlasticityRule};

pub struct CodeGenerator {
    output: Vec<String>,
    indent_level: usize,
}

impl CodeGenerator {
    pub fn new() -> Self {
        CodeGenerator {
            output: Vec::new(),
            indent_level: 0,
        }
    }
    
    pub fn generate(&mut self, ast: AstNode) -> String {
        self.emit_header();
        
        match ast {
            AstNode::Program(declarations) => {
                for decl in declarations {
                    self.generate_declaration(decl);
                }
            }
            _ => {}
        }
        
        self.emit_main();
        self.output.join("\n")
    }
    
    fn emit_header(&mut self) {
        self.emit("// Generated by NeuronLang Compiler - 100% OUR CODE!");
        self.emit("// NO LLVM, NO INTERMEDIATES - Direct .nl ‚Üí Rust ‚Üí Native!");
        self.emit("// HOBERMAN SPHERE CORE - Auto-scaling Neural Architecture!");
        self.emit("// Trinary Neural Network with ZERO baseline energy!");
        self.emit("");
        self.emit("use std::time::Instant;");
        self.emit("use std::sync::Arc;");
        self.emit("use anyhow::Result;");
        self.emit("");
        self.emit("// Import the revolutionary Hoberman sphere!");
        self.emit("use neuronlang_core::hoberman_architecture::{HobermanNeuralSphere, HobermanPlugin, SphereStats};");
        self.emit("use neuronlang_core::{MemorySubstrate, LoopyBeliefPropagation};");
        self.emit("");
        self.emit("#[derive(Debug, Clone, Copy, PartialEq)]");
        self.emit("enum Tryte {");
        self.indent();
        self.emit("Inhibited = -1,");
        self.emit("Baseline = 0,    // ZERO ENERGY - Revolutionary!");
        self.emit("Activated = 1,");
        self.dedent();
        self.emit("}");
        self.emit("");
        self.emit("impl Tryte {");
        self.indent();
        self.emit("fn energy_cost(&self) -> f32 {");
        self.indent();
        self.emit("match self {");
        self.indent();
        self.emit("Tryte::Inhibited => 1.0,  // Active suppression");
        self.emit("Tryte::Baseline => 0.0,   // ZERO ENERGY!");
        self.emit("Tryte::Activated => 1.0,  // Active firing");
        self.dedent();
        self.emit("}");
        self.dedent();
        self.emit("}");
        self.dedent();
        self.emit("}");
        self.emit("");
    }
    
    fn generate_declaration(&mut self, decl: Declaration) {
        match decl.kind {
            DeclKind::Brain(brain) => self.generate_brain(brain),
            _ => {}
        }
    }
    
    fn generate_brain(&mut self, brain: BrainDecl) {
        // Generate the HOBERMAN-POWERED brain struct!
        self.emit(&format!("struct {} {{", brain.name));
        self.indent();
        
        // THE HOBERMAN SPHERE - CORE ARCHITECTURE!
        self.emit("// The auto-scaling neural sphere that adapts to ANY hardware!");
        self.emit("sphere: HobermanNeuralSphere,");
        self.emit("");
        
        // Traditional layers now plug into the sphere
        for layer in &brain.layers {
            self.emit(&format!("{}: Vec<Tryte>,", layer.name));
        }
        
        // Add membrane potentials for spiking neurons
        self.emit("membrane_potentials: Vec<f32>,");
        self.emit("spike_times: Vec<Option<f64>>,");
        self.emit("energy_efficiency: f32,");
        self.emit("baseline_count: usize,");
        self.emit("total_neurons: usize,");
        
        // Traditional components that attach to sphere
        self.emit("memory: Arc<MemorySubstrate>,");
        self.emit("belief_net: Arc<LoopyBeliefPropagation>,");
        self.dedent();
        self.emit("}");
        self.emit("");
        
        // Generate implementation
        self.emit(&format!("impl {} {{", brain.name));
        self.indent();
        
        // Constructor - HOBERMAN SPHERE INITIALIZATION!
        self.emit("async fn new() -> Result<Self> {");
        self.indent();
        self.emit(&format!("println!(\"üåê Initializing {} with Hoberman sphere...\");", brain.name));
        self.emit("");
        
        self.emit("// Step 1: Initialize the auto-scaling sphere");
        self.emit("let sphere = HobermanNeuralSphere::initialize().await?;");
        self.emit("let stats = sphere.get_stats();");
        self.emit("println!(\"  ‚úÖ Sphere expanded to {} neurons across hardware tiers!\", stats.total_neurons);");
        self.emit("");
        
        let total_neurons: usize = brain.layers.iter().map(|l| l.size).sum();
        
        self.emit("// Step 2: Traditional components attach to sphere");
        self.emit("let memory = Arc::new(MemorySubstrate::new());");
        self.emit("let belief_net = Arc::new(LoopyBeliefPropagation::new(1000, 0.001));");
        self.emit("");
        
        self.emit("// Step 3: Initialize layers scaled to sphere");
        self.emit(&format!("let sphere_scale = (stats.total_neurons as f32 / {} as f32).min(1.0);", total_neurons));
        self.emit("");
        
        self.emit("Ok(Self {");
        self.indent();
        self.emit("sphere,");
        
        for layer in &brain.layers {
            self.emit(&format!("{}: vec![Tryte::Baseline; (({}  as f32 * sphere_scale) as usize).max(1)],", layer.name, layer.size));
        }
        
        self.emit(&format!("membrane_potentials: vec![-70.0; (({}  as f32 * sphere_scale) as usize).max(1)],", total_neurons));
        self.emit(&format!("spike_times: vec![None; (({}  as f32 * sphere_scale) as usize).max(1)],", total_neurons));
        self.emit("energy_efficiency: 0.0,");
        self.emit(&format!("baseline_count: (({}  as f32 * sphere_scale) as usize).max(1),", total_neurons));
        self.emit(&format!("total_neurons: (({}  as f32 * sphere_scale) as usize).max(1),", total_neurons));
        self.emit("memory,");
        self.emit("belief_net,");
        self.dedent();
        self.emit("})");
        self.dedent();
        self.emit("}");
        self.emit("");
        
        // Generate process method - SPHERE-POWERED PROCESSING!
        self.emit("fn process(&mut self, input: Vec<f32>) -> Vec<Tryte> {");
        self.indent();
        self.emit("// Step 1: Process through the Hoberman sphere");
        self.emit("let trinary_input: Vec<i8> = input.iter().map(|&x| {");
        self.indent();
        self.emit("if x > 0.5 { 1 } else if x < -0.5 { -1 } else { 0 }");
        self.dedent();
        self.emit("}).collect();");
        self.emit("");
        self.emit("let sphere_output = self.sphere.forward(trinary_input);");
        self.emit("");
        
        self.emit("// Step 2: Traditional layer processing (now scaled by sphere)");
        self.emit("let mut neuron_idx = 0;");
        self.emit("let threshold = -55.0; // Spike threshold in mV");
        self.emit("");
        
        // Process each layer
        for (layer_idx, layer) in brain.layers.iter().enumerate() {
            self.emit(&format!("// Process layer: {}", layer.name));
            self.emit(&format!("for i in 0..{} {{", layer.size));
            self.indent();
            
            // Integrate input
            if layer_idx == 0 {
                self.emit("if i < input.len() {");
                self.indent();
                self.emit("self.membrane_potentials[neuron_idx] += input[i] * 10.0;");
                self.dedent();
                self.emit("}");
            }
            
            // Fire-and-forget dynamics
            self.emit("if self.membrane_potentials[neuron_idx] >= threshold {");
            self.indent();
            self.emit(&format!("self.{}[i] = Tryte::Activated;", layer.name));
            self.emit("// FIRE!");
            self.emit("self.membrane_potentials[neuron_idx] = -80.0; // FORGET! Reset to hyperpolarized");
            self.emit("self.spike_times[neuron_idx] = Some(0.0);");
            self.dedent();
            self.emit("} else if self.membrane_potentials[neuron_idx] < -70.0 {");
            self.indent();
            self.emit(&format!("self.{}[i] = Tryte::Inhibited;", layer.name));
            self.dedent();
            self.emit("} else {");
            self.indent();
            self.emit(&format!("self.{}[i] = Tryte::Baseline; // ZERO ENERGY!", layer.name));
            self.dedent();
            self.emit("}");
            self.emit("neuron_idx += 1;");
            self.dedent();
            self.emit("}");
            self.emit("");
        }
        
        // Calculate energy efficiency
        self.emit("// Calculate energy efficiency");
        self.emit("self.baseline_count = 0;");
        for layer in &brain.layers {
            self.emit(&format!("self.baseline_count += self.{}.iter().filter(|&&n| n == Tryte::Baseline).count();", layer.name));
        }
        self.emit("self.energy_efficiency = (self.baseline_count as f32 / self.total_neurons as f32) * 100.0;");
        self.emit("");
        
        // Return output from last layer
        if let Some(last_layer) = brain.layers.last() {
            self.emit(&format!("self.{}.clone()", last_layer.name));
        } else {
            self.emit("vec![]");
        }
        
        self.dedent();
        self.emit("}");
        
        self.dedent();
        self.emit("}");
        self.emit("");
    }
    
    fn emit_main(&mut self) {
        self.emit("#[tokio::main]");
        self.emit("async fn main() -> Result<()> {");
        self.indent();
        self.emit("println!(\"üåê NeuronLang Runtime - HOBERMAN SPHERE POWERED!\");");
        self.emit("println!(\"==============================================\\n\");");
        self.emit("");
        self.emit("// Create Hoberman-powered brain instance");
        self.emit("println!(\"üåä Dropping ripple to discover hardware...\");");
        self.emit("let mut brain = TradingBrain::new().await?;");
        self.emit("");
        self.emit("// Simulate some input data");
        self.emit("let input = vec![0.5, -0.3, 0.8, 0.1, -0.6];");
        self.emit("");
        self.emit("// Process through the neural network");
        self.emit("let start = Instant::now();");
        self.emit("let output = brain.process(input.clone());");
        self.emit("let elapsed = start.elapsed();");
        self.emit("");
        self.emit("// Display results");
        self.emit("println!(\"‚ö° Processing complete in {:?}\", elapsed);");
        self.emit("println!(\"üîã Energy Efficiency: {:.1}% neurons at ZERO energy baseline!\", brain.energy_efficiency);");
        self.emit("println!(\"üìä Baseline neurons: {}/{}\", brain.baseline_count, brain.total_neurons);");
        self.emit("");
        self.emit("// Show output state distribution");
        self.emit("let activated = output.iter().filter(|&&n| n == Tryte::Activated).count();");
        self.emit("let baseline = output.iter().filter(|&&n| n == Tryte::Baseline).count();");
        self.emit("let inhibited = output.iter().filter(|&&n| n == Tryte::Inhibited).count();");
        self.emit("");
        self.emit("println!(\"\\nüéØ Output Distribution:\");");
        self.emit("println!(\"  Activated (+1): {} neurons\", activated);");
        self.emit("println!(\"  Baseline  (0):  {} neurons (ZERO ENERGY!)\", baseline);");
        self.emit("println!(\"  Inhibited (-1): {} neurons\", inhibited);");
        self.emit("");
        self.emit("// Demonstrate energy savings vs binary");
        self.emit("let binary_energy = brain.total_neurons as f32; // All neurons active in binary");
        self.emit("let trinary_energy = (brain.total_neurons - brain.baseline_count) as f32;");
        self.emit("let savings = ((binary_energy - trinary_energy) / binary_energy) * 100.0;");
        self.emit("");
        self.emit("println!(\"\\nüí∞ Energy Savings vs Binary Neural Networks:\");");
        self.emit("println!(\"  Binary energy cost:  {:.0} units (all neurons active)\", binary_energy);");
        self.emit("println!(\"  Trinary energy cost: {:.0} units (baseline = ZERO!)\", trinary_energy);");
        self.emit("println!(\"  SAVINGS: {:.1}%!\", savings);");
        self.emit("");
        self.emit("println!(\"\\nüåê HOBERMAN SPHERE STATS:\");");
        self.emit("let sphere_stats = brain.sphere.get_stats();");
        self.emit("println!(\"  Expansion level: {:.1}%\", sphere_stats.expansion_level * 100.0);");
        self.emit("println!(\"  L1 neurons: {} (hottest)\", sphere_stats.l1_usage);");
        self.emit("println!(\"  L2 neurons: {} (warm)\", sphere_stats.l2_usage);");
        self.emit("println!(\"  L3 neurons: {} (cool)\", sphere_stats.l3_usage);");
        self.emit("println!(\"  RAM neurons: {} (cold)\", sphere_stats.ram_usage);");
        self.emit("");
        self.emit("println!(\"\\n‚ú® REVOLUTIONARY: Auto-scaling neural network that adapts to ANY hardware!\");");
        self.emit("println!(\"üî• Trinary computing + Hoberman sphere = The future of AI!\");");
        self.emit("");
        self.emit("Ok(())");
        self.dedent();
        self.emit("}");
    }
    
    fn emit(&mut self, line: &str) {
        let indented = "    ".repeat(self.indent_level) + line;
        self.output.push(indented);
    }
    
    fn indent(&mut self) {
        self.indent_level += 1;
    }
    
    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}